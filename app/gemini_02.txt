An谩lisis del Funcionamiento del C贸digo Fuente
El c贸digo implementa un sistema embebido "bare-metal" (sin sistema operativo) que sigue un modelo de planificaci贸n cooperativa basado en tiempo. La l贸gica principal se encuentra en un bucle infinito que ejecuta secuencialmente un conjunto de tareas a intervalos regulares, controlados por la interrupci贸n del temporizador SysTick.

app.c: El Planificador de Tareas 
Este archivo es el n煤cleo del sistema y act煤a como un planificador simple.

app_init(): Se ejecuta una sola vez al inicio para configurar la aplicaci贸n. Llama a las funciones de inicializaci贸n de cada tarea (task_sensor_init, task_menu_init) y prepara los contadores de tiempo.

app_update(): Es el coraz贸n del sistema, llamado continuamente desde main(). Su l贸gica principal es:

Espera a que la interrupci贸n del SysTick incremente la variable g_app_tick_cnt, indicando que ha pasado 1 milisegundo.

Ejecuta la funci贸n update de cada tarea registrada en la lista task_cfg_list (task_sensor_update y task_menu_update).

Mide el tiempo de ejecuci贸n de cada tarea en microsegundos utilizando el contador de ciclos del procesador (DWT).

Acumula el tiempo de todas las tareas en g_app_runtime_us y actualiza el Peor Tiempo de Ejecuci贸n (WCET) de cada tarea si el tiempo actual es mayor que el m谩ximo registrado.

HAL_SYSTICK_Callback(): Es la rutina de servicio de interrupci贸n del SysTick. Se ejecuta cada milisegundo e incrementa los contadores de "ticks" (g_app_tick_cnt, g_task_sensor_tick_cnt, g_task_menu_tick_cnt), que act煤an como el "pulso" que sincroniza todo el sistema.

task_sensor.c: Gesti贸n de Botones 
Esta tarea se encarga de leer el estado de los botones, aplicarles un filtro antirrebote (debouncing) y notificar a otras partes del sistema sobre los eventos.

Funcionamiento: Utiliza una m谩quina de estados finitos (FSM) para cada bot贸n, con los estados UP (liberado), FALLING (transici贸n a presionado), DOWN (presionado) y RISING (transici贸n a liberado).

Filtro Antirrebote: Para evitar lecturas falsas por rebotes mec谩nicos, un bot贸n debe permanecer en un estado estable durante un n煤mero definido de ticks (tick_max, que es 50 ms) antes de que el cambio sea validado.

Comunicaci贸n: Cuando se confirma una pulsaci贸n (ST_BTN_XX_DOWN) o una liberaci贸n (ST_BTN_XX_UP), la tarea env铆a un evento a la task_menu utilizando la funci贸n put_event_task_menu(). Esto desacopla las tareas, permitiendo una comunicaci贸n as铆ncrona.

task_menu.c: Interfaz de Usuario en LCD 
Esta tarea gestiona la l贸gica de la interfaz de usuario, mostrando informaci贸n en una pantalla LCD y reaccionando a los eventos generados por task_sensor.

Funcionamiento: Tambi茅n se basa en una FSM con dos estados principales: ST_MEN_XX_IDLE (en reposo) y ST_MEN_XX_ACTIVE (activo).

Reacci贸n a Eventos: La tarea comprueba si hay eventos pendientes en una cola (any_event_task_menu()). Si recibe un evento de "Enter presionado" (EV_MEN_ENT_ACTIVE), pasa al estado activo.

Actualizaci贸n Peri贸dica: En el estado ST_MEN_XX_ACTIVE, la tarea actualiza un contador num茅rico en la pantalla LCD cada 500 milisegundos (DEL_MEN_XX_MAX).

logger.c y logger.h: Sistema de Registro 锔
Estos archivos proporcionan una funcionalidad simple para enviar mensajes de depuraci贸n a trav茅s de la interfaz de "semihosting", que permite al microcontrolador enviar datos a la consola del depurador en el PC.

LOGGER_INFO(): Es una macro que formatea un mensaje y lo env铆a usando printf.

Funcionamiento Cr铆tico: La funci贸n logger_log_print_ utiliza printf y fflush(stdout). En un entorno de semihosting, esta es una operaci贸n muy lenta y bloqueante, ya que requiere comunicaci贸n con el depurador.

Protecci贸n: La macro LOGGER_LOG deshabilita las interrupciones (CPSID i) antes de imprimir y las rehabilita despu茅s (CPSIE i). Esto asegura que la operaci贸n de log no sea interrumpida, pero tambi茅n significa que el sistema entero se congela durante la transmisi贸n del mensaje.

Impacto de LOGGER_INFO() en el Rendimiento
El uso de LOGGER_INFO() tiene un impacto significativo y negativo en el rendimiento en tiempo real del sistema debido a la naturaleza lenta del semihosting.

g_task_test_tick_cnt
Primero, es importante aclarar que la variable g_task_test_tick_cnt no existe en el c贸digo fuente proporcionado. Las variables que controlan la ejecuci贸n de las tareas son g_task_sensor_tick_cnt y g_task_menu_tick_cnt.

Unidad de medida: Ticks. Cada tick equivale a 1 milisegundo (ms), ya que son incrementados por la interrupci贸n del SysTick.

Impacto: El uso de LOGGER_INFO() no afecta directamente la frecuencia con la que estos contadores se incrementan (la interrupci贸n del SysTick seguir谩 ocurriendo cada 1 ms). Sin embargo, si una tarea tarda m谩s de 1 ms en ejecutarse debido al logging, las tareas comenzar谩n a "perder ticks", lo que significa que no podr谩n procesar cada milisegundo a tiempo, causando un comportamiento err谩tico.

g_app_runtime_us
Unidad de medida: Microsegundos (碌s).

Evoluci贸n Normal: Sin logging, esta variable mide el tiempo total que tardan todas las tareas en ejecutarse en un ciclo de 1 ms. Su valor suele ser bajo (decenas o cientos de microsegundos) y se resetea a cero al inicio de cada ciclo en app_update.

Impacto de LOGGER_INFO():

Cuando una tarea llama a LOGGER_INFO(), su tiempo de ejecuci贸n se dispara, pudiendo tardar varios milisegundos.

Este tiempo tan largo se suma a g_app_runtime_us.

Como resultado, en los ciclos donde se ejecuta un LOGGER_INFO(), el valor de g_app_runtime_us se incrementar谩 dr谩sticamente, reflejando el alto costo de la operaci贸n de E/S del semihosting.

task_dta_list[index].WCET (Worst-Case Execution Time)
Unidad de medida: Microsegundos (碌s).

Evoluci贸n Normal: Esta variable act煤a como un "r茅cord" del tiempo m谩s largo que ha tardado una tarea en ejecutarse. Se inicializa en cero y solo se actualiza si el tiempo de ejecuci贸n actual supera el m谩ximo anterior.

Impacto de LOGGER_INFO():

La primera vez que una tarea llame a LOGGER_INFO(), su tiempo de ejecuci贸n medido ser谩 muy alto.

El planificador en app_update detectar谩 este pico y actualizar谩 el WCET de esa tarea a este nuevo valor m谩ximo.

A diferencia de g_app_runtime_us que se resetea en cada ciclo, el valor de WCET, una vez actualizado, permanecer谩 alto para siempre. Esto proporciona una indicaci贸n clara de que la tarea tuvo un pico de ejecuci贸n, aunque puede ser enga帽oso si el logging solo se usa para depuraci贸n y no forma parte de la l贸gica final.

En resumen, aunque LOGGER_INFO() es una herramienta de depuraci贸n invaluable, introduce una sobrecarga de tiempo masiva que distorsiona las m茅tricas de rendimiento en tiempo real. Para medir el rendimiento real del sistema, todas las llamadas de logging deber铆an estar deshabilitadas.